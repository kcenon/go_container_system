package tests

import (
	"strings"
	"testing"

	"github.com/kcenon/go_container_system/container/core"
	"github.com/kcenon/go_container_system/container/values"
	"github.com/kcenon/go_container_system/container/wireprotocol"
)

// Test data generated by C++ container_system
const cppWireData = `@header={{[3,cpp_client];[4,session1];[1,go_server];[2,main];[5,test_message];[6,1.0.0.0];}};@data={{[count,int_value,42];[name,string_value,TestUser];[active,bool_value,true];[balance,double_value,1500.75];}};`

// Test data generated by Python container_system (verified 100% compatible with C++)
const pythonWireData = `@header={{[3,python_client];[4,worker1];[1,go_server];[2,handler];[5,user_event];[6,1.0.0.0];}};@data={{[user_id,int_value,12345];[email,string_value,test@example.com];[verified,bool_value,true];}};`

// Test data generated by Rust container_system
const rustWireData = `@header={{[3,rust_client];[4,thread_1];[1,go_server];[2,worker];[5,data_sync];[6,1.0.0.0];}};@data={{[sequence,int_value,100];[payload,string_value,hello_go];[compressed,bool_value,false];}};`

func TestDeserializeCppData(t *testing.T) {
	// Parse data generated by C++ system
	container, err := wireprotocol.DeserializeCppWire(cppWireData)
	if err != nil {
		t.Fatalf("Failed to deserialize C++ wire data: %v", err)
	}

	// Verify header fields
	if container.SourceID() != "cpp_client" {
		t.Errorf("Expected source_id 'cpp_client', got '%s'", container.SourceID())
	}
	if container.SourceSubID() != "session1" {
		t.Errorf("Expected source_sub_id 'session1', got '%s'", container.SourceSubID())
	}
	if container.TargetID() != "go_server" {
		t.Errorf("Expected target_id 'go_server', got '%s'", container.TargetID())
	}
	if container.MessageType() != "test_message" {
		t.Errorf("Expected message_type 'test_message', got '%s'", container.MessageType())
	}

	// Verify value count
	if len(container.Values()) != 4 {
		t.Errorf("Expected 4 values, got %d", len(container.Values()))
	}

	// Verify int value
	count := container.GetValue("count", 0)
	if count == nil {
		t.Fatal("Missing 'count' value")
	}
	countVal, err := count.ToInt32()
	if err != nil {
		t.Fatalf("Failed to convert count: %v", err)
	}
	if countVal != 42 {
		t.Errorf("Expected count=42, got %d", countVal)
	}

	// Verify string value
	name := container.GetValue("name", 0)
	if name == nil {
		t.Fatal("Missing 'name' value")
	}
	nameVal, err := name.ToString()
	if err != nil {
		t.Fatalf("Failed to convert name: %v", err)
	}
	if nameVal != "TestUser" {
		t.Errorf("Expected name='TestUser', got '%s'", nameVal)
	}

	// Verify bool value
	active := container.GetValue("active", 0)
	if active == nil {
		t.Fatal("Missing 'active' value")
	}
	activeVal, err := active.ToBool()
	if err != nil {
		t.Fatalf("Failed to convert active: %v", err)
	}
	if !activeVal {
		t.Error("Expected active=true")
	}

	// Verify double value
	balance := container.GetValue("balance", 0)
	if balance == nil {
		t.Fatal("Missing 'balance' value")
	}
	balanceVal, err := balance.ToFloat64()
	if err != nil {
		t.Fatalf("Failed to convert balance: %v", err)
	}
	if balanceVal < 1500.7 || balanceVal > 1500.8 {
		t.Errorf("Expected balanceâ‰ˆ1500.75, got %f", balanceVal)
	}
}

func TestDeserializePythonData(t *testing.T) {
	// Parse data generated by Python system
	container, err := wireprotocol.DeserializeCppWire(pythonWireData)
	if err != nil {
		t.Fatalf("Failed to deserialize Python wire data: %v", err)
	}

	// Verify header fields
	if container.SourceID() != "python_client" {
		t.Errorf("Expected source_id 'python_client', got '%s'", container.SourceID())
	}
	if container.MessageType() != "user_event" {
		t.Errorf("Expected message_type 'user_event', got '%s'", container.MessageType())
	}

	// Verify value count
	if len(container.Values()) != 3 {
		t.Errorf("Expected 3 values, got %d", len(container.Values()))
	}

	// Verify user_id
	userID := container.GetValue("user_id", 0)
	if userID == nil {
		t.Fatal("Missing 'user_id' value")
	}
	userIDVal, err := userID.ToInt32()
	if err != nil {
		t.Fatalf("Failed to convert user_id: %v", err)
	}
	if userIDVal != 12345 {
		t.Errorf("Expected user_id=12345, got %d", userIDVal)
	}
}

func TestDeserializeRustData(t *testing.T) {
	// Parse data generated by Rust system
	container, err := wireprotocol.DeserializeCppWire(rustWireData)
	if err != nil {
		t.Fatalf("Failed to deserialize Rust wire data: %v", err)
	}

	// Verify header fields
	if container.SourceID() != "rust_client" {
		t.Errorf("Expected source_id 'rust_client', got '%s'", container.SourceID())
	}
	if container.MessageType() != "data_sync" {
		t.Errorf("Expected message_type 'data_sync', got '%s'", container.MessageType())
	}

	// Verify value count
	if len(container.Values()) != 3 {
		t.Errorf("Expected 3 values, got %d", len(container.Values()))
	}

	// Verify sequence
	sequence := container.GetValue("sequence", 0)
	if sequence == nil {
		t.Fatal("Missing 'sequence' value")
	}
	if val, _ := sequence.ToInt32(); val != 100 {
		t.Errorf("Expected sequence=100, got %d", val)
	}
}

func TestGoToCppFormat(t *testing.T) {
	// Create container in Go
	container := core.NewValueContainer()
	container.SetSource("go_client", "goroutine_1")
	container.SetTarget("cpp_server", "worker")
	container.SetMessageType("data_sync")

	container.AddValue(values.NewInt32Value("sequence", 100))
	container.AddValue(values.NewStringValue("payload", "hello_cpp"))
	container.AddValue(values.NewBoolValue("compressed", false))

	// Serialize to wire format
	wireData, err := wireprotocol.SerializeCppWire(container)
	if err != nil {
		t.Fatalf("Serialization failed: %v", err)
	}

	// Verify format matches C++ expectations
	if !strings.HasPrefix(wireData, "@header={{") {
		t.Error("Wire data should start with '@header={{'")
	}
	if !strings.Contains(wireData, "@data={{") {
		t.Error("Wire data should contain '@data={{'")
	}
	if !strings.Contains(wireData, "[3,go_client]") { // source_id
		t.Error("Missing [3,go_client] in wire data")
	}
	if !strings.Contains(wireData, "[5,data_sync]") { // message_type
		t.Error("Missing [5,data_sync] in wire data")
	}
	if !strings.Contains(wireData, "[sequence,int_value,100]") {
		t.Error("Missing [sequence,int_value,100] in wire data")
	}

	// Verify can be deserialized back
	restored, err := wireprotocol.DeserializeCppWire(wireData)
	if err != nil {
		t.Fatalf("Failed to deserialize own data: %v", err)
	}
	if restored.SourceID() != "go_client" {
		t.Errorf("Expected source_id 'go_client', got '%s'", restored.SourceID())
	}
	if len(restored.Values()) != 3 {
		t.Errorf("Expected 3 values, got %d", len(restored.Values()))
	}
}

func TestNumericTypesInterop(t *testing.T) {
	// Test core numeric types for cross-language compatibility
	container := core.NewValueContainer()
	container.SetMessageType("numeric_test")

	container.AddValue(values.NewInt32Value("i32", -123456))
	container.AddValue(values.NewInt64Value("i64", -9876543210))
	container.AddValue(values.NewFloat32Value("f32", 3.14159))
	container.AddValue(values.NewFloat64Value("f64", 2.71828182845))

	wireData, err := wireprotocol.SerializeCppWire(container)
	if err != nil {
		t.Fatalf("Serialization failed: %v", err)
	}

	// Verify all types are present
	if !strings.Contains(wireData, "int_value") {
		t.Error("Missing int_value in wire data")
	}
	if !strings.Contains(wireData, "llong_value") {
		t.Error("Missing llong_value in wire data")
	}
	if !strings.Contains(wireData, "float_value") {
		t.Error("Missing float_value in wire data")
	}
	if !strings.Contains(wireData, "double_value") {
		t.Error("Missing double_value in wire data")
	}

	// Roundtrip test
	restored, err := wireprotocol.DeserializeCppWire(wireData)
	if err != nil {
		t.Fatalf("Deserialization failed: %v", err)
	}
	if len(restored.Values()) != 4 {
		t.Errorf("Expected 4 values, got %d", len(restored.Values()))
	}

	// Verify values
	i32 := restored.GetValue("i32", 0)
	if i32 != nil {
		if val, _ := i32.ToInt32(); val != -123456 {
			t.Errorf("i32 mismatch")
		}
	} else {
		t.Errorf("i32 is nil")
	}

	i64 := restored.GetValue("i64", 0)
	if i64 != nil {
		if val, _ := i64.ToInt64(); val != -9876543210 {
			t.Errorf("i64 mismatch")
		}
	} else {
		t.Errorf("i64 is nil")
	}
}

func TestBytesInterop(t *testing.T) {
	// Test binary data exchange (hex encoding)
	container := core.NewValueContainer()
	container.SetMessageType("binary_transfer")

	testBytes := []byte{0xDE, 0xAD, 0xBE, 0xEF, 0xCA, 0xFE}
	container.AddValue(values.NewBytesValue("signature", testBytes))

	wireData, err := wireprotocol.SerializeCppWire(container)
	if err != nil {
		t.Fatalf("Serialization failed: %v", err)
	}

	// Verify hex encoding (C++ uses hex, not base64)
	if !strings.Contains(wireData, "deadbeefcafe") {
		t.Error("Expected hex-encoded bytes 'deadbeefcafe' in wire data")
	}

	// Verify deserialization
	restored, err := wireprotocol.DeserializeCppWire(wireData)
	if err != nil {
		t.Fatalf("Deserialization failed: %v", err)
	}

	signature := restored.GetValue("signature", 0)
	if signature == nil {
		t.Fatal("Missing 'signature' value")
	}

	restoredBytes, _ := signature.ToBytes()
	if len(restoredBytes) != len(testBytes) {
		t.Errorf("Byte length mismatch: expected %d, got %d", len(testBytes), len(restoredBytes))
	}

	for i := range testBytes {
		if restoredBytes[i] != testBytes[i] {
			t.Errorf("Byte mismatch at index %d: expected %x, got %x", i, testBytes[i], restoredBytes[i])
		}
	}
}

func TestEmptyContainerInterop(t *testing.T) {
	// Test empty container (edge case)
	container := core.NewValueContainer()
	container.SetSource("go", "")
	container.SetMessageType("ping")

	wireData, err := wireprotocol.SerializeCppWire(container)
	if err != nil {
		t.Fatalf("Serialization failed: %v", err)
	}

	// Should have header and empty data
	if !strings.Contains(wireData, "@header={{") {
		t.Error("Missing header")
	}
	if !strings.Contains(wireData, "@data={{") {
		t.Error("Missing data section")
	}
	if !strings.HasSuffix(wireData, "}};") {
		t.Error("Wire data should end with '}},'")
	}

	// Roundtrip
	restored, err := wireprotocol.DeserializeCppWire(wireData)
	if err != nil {
		t.Fatalf("Deserialization failed: %v", err)
	}
	if len(restored.Values()) != 0 {
		t.Errorf("Expected 0 values, got %d", len(restored.Values()))
	}
	if restored.MessageType() != "ping" {
		t.Errorf("Expected message_type 'ping', got '%s'", restored.MessageType())
	}
}

func TestSpecialCharactersInStrings(t *testing.T) {
	// Test strings with special characters
	container := core.NewValueContainer()
	container.SetMessageType("special_chars")

	container.AddValue(values.NewStringValue("text", "Hello, World!"))
	container.AddValue(values.NewStringValue("path", "/usr/local/bin"))
	container.AddValue(values.NewStringValue("expr", "a=b+c"))

	wireData, err := wireprotocol.SerializeCppWire(container)
	if err != nil {
		t.Fatalf("Serialization failed: %v", err)
	}

	// Roundtrip
	restored, err := wireprotocol.DeserializeCppWire(wireData)
	if err != nil {
		t.Fatalf("Deserialization failed: %v", err)
	}

	text := restored.GetValue("text", 0)
	if text != nil {
		if val, _ := text.ToString(); val != "Hello, World!" {
			t.Errorf("text mismatch")
		}
	} else {
		t.Errorf("text is nil")
	}

	path := restored.GetValue("path", 0)
	if path != nil {
		if val, _ := path.ToString(); val != "/usr/local/bin" {
			t.Errorf("path mismatch")
		}
	} else {
		t.Errorf("path is nil")
	}

	expr := restored.GetValue("expr", 0)
	if expr != nil {
		if val, _ := expr.ToString(); val != "a=b+c" {
			t.Errorf("expr mismatch")
		}
	} else {
		t.Errorf("expr is nil")
	}
}
