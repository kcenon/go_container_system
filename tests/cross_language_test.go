/****************************************************************************
BSD 3-Clause License

Copyright (c) 2021, üçÄ‚òÄüåïüå• üåä
All rights reserved.
****************************************************************************/

package tests

import (
	"testing"

	"github.com/kcenon/go_container_system/container/core"
	"github.com/kcenon/go_container_system/container/values"
	"github.com/kcenon/go_container_system/container/wireprotocol"
)

// TestCrossLanguage_CppWireProtocol tests that Go's wire protocol output matches
// what C++/Python/Rust systems expect.
//
// Format: @header={{[id,value];...}};@data={{[name,type_name,value];...}};
func TestCrossLanguage_CppWireProtocol(t *testing.T) {
	container := core.NewValueContainer()
	container.SetSource("go_client", "session1")
	container.SetTarget("cpp_server", "handler")
	container.SetMessageType("test_message")

	// Add various values
	container.AddValue(values.NewInt32Value("count", 42))
	container.AddValue(values.NewStringValue("name", "TestUser"))
	container.AddValue(values.NewBoolValue("active", true))
	container.AddValue(values.NewFloat64Value("balance", 1500.75))

	wireData, err := wireprotocol.SerializeCppWire(container)
	if err != nil {
		t.Fatalf("SerializeCppWire failed: %v", err)
	}

	t.Logf("Go-generated wire protocol:\n%s", wireData)

	// Verify it can be deserialized back
	restored, err := wireprotocol.DeserializeCppWire(wireData)
	if err != nil {
		t.Fatalf("DeserializeCppWire failed: %v", err)
	}

	// Verify header fields
	if restored.SourceID() != "go_client" {
		t.Errorf("SourceID mismatch: expected 'go_client', got '%s'", restored.SourceID())
	}
	if restored.TargetID() != "cpp_server" {
		t.Errorf("TargetID mismatch: expected 'cpp_server', got '%s'", restored.TargetID())
	}

	// Verify values
	countVal := restored.GetValue("count", 0)
	if countVal == nil || countVal.Type() == core.NullValue {
		t.Error("count value not found")
	} else {
		val, _ := countVal.ToInt32()
		if val != 42 {
			t.Errorf("count mismatch: expected 42, got %d", val)
		}
	}

	nameVal := restored.GetValue("name", 0)
	if nameVal == nil || nameVal.Type() == core.NullValue {
		t.Error("name value not found")
	} else {
		val, _ := nameVal.ToString()
		if val != "TestUser" {
			t.Errorf("name mismatch: expected 'TestUser', got '%s'", val)
		}
	}

	t.Log("‚úì Go wire protocol roundtrip successful")
}

// TestCrossLanguage_DeserializeCppData tests deserializing data generated by C++ systems
func TestCrossLanguage_DeserializeCppData(t *testing.T) {
	// Wire protocol data as if generated by C++
	// Format: @header={{[3,source];[4,subsrc];[1,target];[2,subtgt];[5,type];[6,version];}};@data={{[name,type,value];...}};
	cppData := `@header={{[3,cpp_client];[4,session1];[1,go_server];[2,main];[5,test_message];[6,1.0.0.0];}};@data={{[count,int_value,42];[name,string_value,TestUser];[active,bool_value,true];[balance,double_value,1500.75];}};`

	container, err := wireprotocol.DeserializeCppWire(cppData)
	if err != nil {
		t.Fatalf("Failed to deserialize C++ data: %v", err)
	}

	// Verify header
	if container.SourceID() != "cpp_client" {
		t.Errorf("SourceID mismatch: expected 'cpp_client', got '%s'", container.SourceID())
	}
	if container.TargetID() != "go_server" {
		t.Errorf("TargetID mismatch: expected 'go_server', got '%s'", container.TargetID())
	}
	if container.MessageType() != "test_message" {
		t.Errorf("MessageType mismatch: expected 'test_message', got '%s'", container.MessageType())
	}

	// Verify values
	vals := container.Values()
	if len(vals) != 4 {
		t.Errorf("Expected 4 values, got %d", len(vals))
	}

	// Check int value
	countVal := container.GetValue("count", 0)
	if countVal.Type() != core.IntValue {
		t.Errorf("count type mismatch: expected IntValue, got %v", countVal.Type())
	}

	// Check string value
	nameVal := container.GetValue("name", 0)
	if nameVal.Type() != core.StringValue {
		t.Errorf("name type mismatch: expected StringValue, got %v", nameVal.Type())
	}

	t.Log("‚úì Successfully deserialized C++ wire protocol data")
}

// TestCrossLanguage_DeserializePythonData tests deserializing data generated by Python
func TestCrossLanguage_DeserializePythonData(t *testing.T) {
	// Wire protocol data as if generated by Python
	pythonData := `@header={{[3,python_client];[4,worker1];[1,go_server];[2,handler];[5,user_event];[6,1.0.0.0];}};@data={{[user_id,int_value,12345];[email,string_value,test@example.com];[verified,bool_value,true];}};`

	container, err := wireprotocol.DeserializeCppWire(pythonData)
	if err != nil {
		t.Fatalf("Failed to deserialize Python data: %v", err)
	}

	// Verify header
	if container.SourceID() != "python_client" {
		t.Errorf("SourceID mismatch: expected 'python_client', got '%s'", container.SourceID())
	}

	// Verify values
	userID := container.GetValue("user_id", 0)
	if userID == nil || userID.Type() == core.NullValue {
		t.Error("user_id value not found")
	} else {
		val, _ := userID.ToInt32()
		if val != 12345 {
			t.Errorf("user_id mismatch: expected 12345, got %d", val)
		}
	}

	email := container.GetValue("email", 0)
	if email == nil || email.Type() == core.NullValue {
		t.Error("email value not found")
	} else {
		val, _ := email.ToString()
		if val != "test@example.com" {
			t.Errorf("email mismatch: expected 'test@example.com', got '%s'", val)
		}
	}

	t.Log("‚úì Successfully deserialized Python wire protocol data")
}

// TestCrossLanguage_NestedContainer tests nested container serialization/deserialization
func TestCrossLanguage_NestedContainer(t *testing.T) {
	// Create nested structure
	innerContainer := values.NewContainerValue("user_info",
		values.NewStringValue("username", "john_doe"),
		values.NewInt32Value("age", 30),
	)

	container := core.NewValueContainer()
	container.SetMessageType("nested_test")
	container.AddValue(innerContainer)
	container.AddValue(values.NewStringValue("request_id", "req-123"))

	wireData, err := wireprotocol.SerializeCppWire(container)
	if err != nil {
		t.Fatalf("SerializeCppWire failed: %v", err)
	}

	t.Logf("Nested container wire data:\n%s", wireData)

	// Deserialize
	restored, err := wireprotocol.DeserializeCppWire(wireData)
	if err != nil {
		t.Fatalf("DeserializeCppWire failed: %v", err)
	}

	// Verify nested container
	nestedVal := restored.GetValue("user_info", 0)
	if nestedVal == nil || nestedVal.Type() == core.NullValue {
		t.Error("user_info nested container not found")
	} else if nestedVal.Type() != core.ContainerValue {
		t.Errorf("user_info type mismatch: expected ContainerValue, got %v", nestedVal.Type())
	} else {
		containerVal, ok := nestedVal.(*values.ContainerValue)
		if !ok {
			t.Error("Failed to cast to ContainerValue")
		} else {
			if containerVal.ChildCount() != 2 {
				t.Errorf("Expected 2 children, got %d", containerVal.ChildCount())
			}
			// Check child values
			usernameVal := containerVal.GetChild("username", 0)
			if usernameVal != nil && usernameVal.Type() == core.StringValue {
				val, _ := usernameVal.ToString()
				if val != "john_doe" {
					t.Errorf("username mismatch: expected 'john_doe', got '%s'", val)
				}
			}
		}
	}

	t.Log("‚úì Nested container roundtrip successful")
}

// TestCrossLanguage_ArrayValue tests array serialization/deserialization
func TestCrossLanguage_ArrayValue(t *testing.T) {
	// Create array with mixed types
	arrayVal := values.NewArrayValue("scores",
		values.NewInt32Value("", 100),
		values.NewInt32Value("", 95),
		values.NewInt32Value("", 87),
	)

	container := core.NewValueContainer()
	container.SetMessageType("array_test")
	container.AddValue(arrayVal)

	wireData, err := wireprotocol.SerializeCppWire(container)
	if err != nil {
		t.Fatalf("SerializeCppWire failed: %v", err)
	}

	t.Logf("Array wire data:\n%s", wireData)

	// Deserialize
	restored, err := wireprotocol.DeserializeCppWire(wireData)
	if err != nil {
		t.Fatalf("DeserializeCppWire failed: %v", err)
	}

	// Verify array
	scoresVal := restored.GetValue("scores", 0)
	if scoresVal == nil || scoresVal.Type() == core.NullValue {
		t.Error("scores array not found")
	} else if scoresVal.Type() != core.ArrayValue {
		t.Errorf("scores type mismatch: expected ArrayValue, got %v", scoresVal.Type())
	} else {
		av, ok := scoresVal.(*values.ArrayValue)
		if !ok {
			t.Error("Failed to cast to ArrayValue")
		} else {
			if av.Count() != 3 {
				t.Errorf("Expected 3 elements, got %d", av.Count())
			}
		}
	}

	t.Log("‚úì Array roundtrip successful")
}

// TestCrossLanguage_TypeIDCompatibility verifies type IDs match C++/Python/.NET
func TestCrossLanguage_TypeIDCompatibility(t *testing.T) {
	// C++ value_types.h defines:
	// 12 = string_value (matches std::string position in variant)
	// 13 = bytes_value (matches std::vector<uint8_t> position in variant)

	expectedTypes := map[string]int{
		"NullValue":      0,
		"BoolValue":      1,
		"ShortValue":     2,
		"UShortValue":    3,
		"IntValue":       4,
		"UIntValue":      5,
		"LongValue":      6,
		"ULongValue":     7,
		"LLongValue":     8,
		"ULLongValue":    9,
		"FloatValue":     10,
		"DoubleValue":    11,
		"StringValue":    12, // Critical: Must match C++ std::string position
		"BytesValue":     13, // Critical: Must match C++ std::vector<uint8_t> position
		"ContainerValue": 14,
		"ArrayValue":     15,
	}

	actualTypes := map[string]core.ValueType{
		"NullValue":      core.NullValue,
		"BoolValue":      core.BoolValue,
		"ShortValue":     core.ShortValue,
		"UShortValue":    core.UShortValue,
		"IntValue":       core.IntValue,
		"UIntValue":      core.UIntValue,
		"LongValue":      core.LongValue,
		"ULongValue":     core.ULongValue,
		"LLongValue":     core.LLongValue,
		"ULLongValue":    core.ULLongValue,
		"FloatValue":     core.FloatValue,
		"DoubleValue":    core.DoubleValue,
		"StringValue":    core.StringValue,
		"BytesValue":     core.BytesValue,
		"ContainerValue": core.ContainerValue,
		"ArrayValue":     core.ArrayValue,
	}

	for name, expected := range expectedTypes {
		actual := int(actualTypes[name])
		if actual != expected {
			t.Errorf("%s type ID mismatch: expected %d, got %d", name, expected, actual)
		} else {
			t.Logf("‚úì %s = %d", name, actual)
		}
	}
}

// TestCrossLanguage_BytesAndStringDistinct ensures bytes and string are handled distinctly
func TestCrossLanguage_BytesAndStringDistinct(t *testing.T) {
	// Create both string and bytes with same content
	strContent := "Hello"
	bytesContent := []byte{0x48, 0x65, 0x6c, 0x6c, 0x6f} // "Hello" in bytes

	container := core.NewValueContainer()
	container.SetMessageType("bytes_string_test")
	container.AddValue(values.NewStringValue("str_hello", strContent))
	container.AddValue(values.NewBytesValue("bytes_hello", bytesContent))

	wireData, err := wireprotocol.SerializeCppWire(container)
	if err != nil {
		t.Fatalf("SerializeCppWire failed: %v", err)
	}

	t.Logf("Wire data:\n%s", wireData)

	// Deserialize
	restored, err := wireprotocol.DeserializeCppWire(wireData)
	if err != nil {
		t.Fatalf("DeserializeCppWire failed: %v", err)
	}

	// Verify string
	strVal := restored.GetValue("str_hello", 0)
	if strVal.Type() != core.StringValue {
		t.Errorf("str_hello type mismatch: expected StringValue (12), got %v (%d)",
			strVal.Type().TypeName(), int(strVal.Type()))
	}

	// Verify bytes
	bytesVal := restored.GetValue("bytes_hello", 0)
	if bytesVal.Type() != core.BytesValue {
		t.Errorf("bytes_hello type mismatch: expected BytesValue (13), got %v (%d)",
			bytesVal.Type().TypeName(), int(bytesVal.Type()))
	}

	t.Log("‚úì Bytes and String are correctly distinguished")
}
